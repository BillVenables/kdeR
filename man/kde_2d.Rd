% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kernel_density.R
\name{kde_2d}
\alias{kde_2d}
\alias{print.kde_2d}
\alias{plot.kde_2d}
\alias{as.data.frame.kde_2d}
\title{Two Dimensional Kernel Density Estimate}
\usage{
kde_2d(
  x,
  y,
  N = 128,
  bw = c(x = bw.nrd0(x), y = bw.nrd0(y)),
  lower_x = limits$x$lower,
  upper_x = limits$x$upper,
  lower_y = limits$y$lower,
  upper_y = limits$y$upper,
  algorithm1 = length(x) < 2 * Nxy,
  k = 1
)

\method{print}{kde_2d}(x, ...)

\method{plot}{kde_2d}(
  x,
  ...,
  xlab = bquote(italic(.(x$data_name[["x"]]))),
  ylab = bquote(italic(.(x$data_name[["y"]]))),
  col = hcl.colors(25, rev = TRUE)
)

\method{as.data.frame}{kde_2d}(
  x,
  row.names,
  optional,
  ...,
  borders = FALSE,
  responseName = "density"
)
}
\arguments{
\item{x}{Numeric vector or, in generics, a kde object}

\item{y}{Numeric vector of the response Variables}

\item{N}{Integer: number of equally spaced points for the
kde.  May be one or two for x and y respectively}

\item{bw}{Numeric: bandwidth(s) for x and y kernels
respectively.  A single value will be duplicated.}

\item{lower_x, upper_x, lower_y, upper_y}{Numeric: kde range limits}

\item{algorithm1}{Logical: should the smaller sample
algorithm be used?}

\item{k}{Ineger: number of bandwidths by which to increase
the range for the default limits.}

\item{...}{Extra arguments passed on to methods.}

\item{xlab, ylab, col}{base graphics parameters}

\item{row.names, optional}{As for the as.data.frame generic}

\item{borders}{logical: should zero borders be included around
the density when the object is coerced to a data frame.}

\item{responseName}{character string: name for the density vector.}
}
\value{
An object of class "kde_2d"
}
\description{
A pure R implementation of two direct algorithms.
}
\examples{
set.seed(1234)
x_value <- abs(rnorm(5000))
y_value <- rnorm(x_value)
kxy <- kde_2d(x_value, y_value, lower_x = 0)
kxy
if("package:ggplot2" \%in\% search()) {
    ggplot(within(as.data.frame(kxy),
                  pDens <- 2*dnorm(x_value)*dnorm(y_value))) +
      aes(x = x_value, y = y_value) +
      geom_raster(aes(fill = density)) +
      geom_contour(aes(z = pDens), colour = "firebrick3") +
      scale_fill_viridis_c(direction = -1) +
      theme_bw() + theme(legend.position = "none")
} else {
  with(unclass(kxy), {
    par(mar = c(3, 3, 1, 1) + 0.1, las = 1, mgp = c(1.5, 0.5, 0),
        cex.axis = 0.7, cex.lab = 0.8, tck = -0.025)
    plot(kxy)
    contour(x, y, col = "firebrick3",
            z = outer(x, y, function(x, y)
              2*dnorm(x)*dnorm(y)),
            nlevels = 6, add = TRUE)
    box()
  })
}
rm(x_value, y_value)
}
